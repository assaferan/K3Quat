freeze;// exports:// intrinsic DiscriminantGroup(Q::AlgMatElt[FldRat]) -> GrpAb// intrinsic IsIntegral(Q::AlgMatElt[FldRat]) -> BoolElt// intrinsic IsEven(Q::AlgMatElt[FldRat]) -> BoolElt// intrinsic BuildLattice(O_B::AlgAssVOrd[RngOrd[RngInt]],//		       i::AlgQuatElt[FldNum[FldRat]],//		       delta::FldNumElt[FldRat]//			    : dual := false) -> AlgMatElt[FldRat]// intrinsic BuildRandomLattice(K::FldNum[FldRat] ://			     ps_bound := 100, split2 := 0,//			     dual := false, sign := 2) -> AlgMatElt[FldRat]// Starting from cubic fields// _<x> := PolynomialRing(Rationals());// K := NumberField(x^3 - x^2 - 2*x + 1);// K := RationalsAsNumberField();// K := NumberField(x^7 - x^6 - 6*x^5 + 4*x^4 + 10*x^3 - 4*x^2 - 4*x + 1);intrinsic DiscriminantGroup(Q::AlgMatElt[FldRat]) -> GrpAb{Computes the discirminant group of the lattice with Gram matrix Q.}    nfl := NumberFieldLattice(RationalsAsNumberField(), Nrows(Q) : Gram := Q);    // Verifying that the dual lattice was not scaled    assert nfl subset Dual(nfl);    elem := ElementaryDivisors(Module(Dual(nfl)), Module(nfl));    // returning the relevant abelian group    disc<[a]> := AbelianGroup([Integers() | Norm(x) : x in elem | 					    Norm(x) ne 1]);    return disc;end intrinsic;intrinsic IsIntegral(Q::AlgMatElt[FldRat]) -> BoolElt{Return true if all the matrix entries are integral.}   return &and[IsIntegral(x) : x in Eltseq(Q)];end intrinsic;intrinsic IsEven(Q::AlgMatElt[FldRat]) -> BoolElt{Returns true if the matrix is integral and all the diagonal entries are even.}    is_integral := IsIntegral(Q);    return is_integral and	   (&and[IsEven(Integers()!Q[i,i]) : i in [1..Nrows(Q)]]);end intrinsic;// Here i should be an element whose norm has signature (3*Degree(K)-1,1)intrinsic BuildLattice(O_B::AlgAssVOrd[RngOrd[RngInt]],		       i::AlgQuatElt[FldNum[FldRat]],		       delta::FldNumElt[FldRat]		       : dual := false) -> AlgMatElt[FldRat]{Returns a lattice constructed from a ternary lattice in O_B of elements perpendicular to i, with norm form Trace(delta xy).}    idls := [x[1] : x in PseudoBasis(O_B)];    basis := [x[2] : x in PseudoBasis(O_B)];    if (dual) then	gram_O := Matrix([[Norm(x+y)-Norm(x)-Norm(y) : y in basis] : x in basis]);	O_B_nfl := NumberFieldLattice([Vector(Eltseq(b)) : b in basis] : Gram := gram_O, Ideals := idls);	O_B_dual := Dual(O_B_nfl);	idls := CoefficientIdeals(O_B_dual);	B := Algebra(O_B);	basis := [B!v : v in PseudoBasis(O_B_dual)];    end if;    basisR := &cat[ [ x*basis[idx] : x in Basis(idls[idx])]		    : idx in [1..#idls] ];    R := BaseRing(O_B);    ker_basis := Basis(Kernel(ChangeRing(Matrix([Eltseq(R!Trace(i*x)) : x in basisR]), Integers())));        basis_O_B_0 := [&+[basisR[i]*b[i] : i in [1..#basisR]] : b in ker_basis];    assert &and [Trace(i*x) eq 0 : x in basis_O_B_0];    if (not dual) then 	assert &and [x in O_B : x in basis_O_B_0];    end if;        // Q_K := Matrix([[Norm(x+y)-Norm(x)-Norm(y) : y in basis_O_B_0] : x in basis_O_B_0]);    Q := Matrix([[-Trace(delta*(Norm(x+y)-Norm(x)-Norm(y))) : y in basis_O_B_0] : x in basis_O_B_0]);    if (dual) then	Q := Matrix([[-Trace(Norm(x+y)-Norm(x)-Norm(y)) : y in basis_O_B_0] : x in basis_O_B_0]);    end if;    print "Gram matrix is...", Q;    plus, minus := Signature(Q);    // Verifying we have the correct signature    print "Signature is... ", Signature(Q);    // Currently that doesn't work for the dual - we would need to undo the different    return Q;end intrinsic;// Returns a delta with Degree(K)-1 negative signsfunction find_delta(K)    ZK := Integers(K);    // Different is principal generated by f'(alpha)    _, codelta := IsPrincipal(Different(ZK));    delta := codelta^(-1);    U, mU := UnitGroup(ZK);    Ugens := [U.i : i in [1..Ngens(U)]];    unit_signs := [[GF(2) ! 1 - ((Sign(x) + 1 ) div 2) : x in RealEmbeddings(mU(gU))] : gU in Ugens];    us := Matrix(unit_signs);    delta_signs := [Sign(x) : x in RealEmbeddings(delta)];    vec := Vector([GF(2)! 1 - ((s + 1) div 2) : s in delta_signs]);        for j in [1..Degree(vec)] do	vec_j := Vector(vec);	vec_j[j] +:= 1;	if vec_j in RowSpace(us) then	    u_vec := Solution(us, vec_j);	    break;	end if;    end for;    u := K!mU(U!Eltseq(u_vec));    return -u*delta;end function;intrinsic BuildRandomLattice(K::FldNum[FldRat] :			     ps_bound := 100, split2 := 0,			     dual := false, sign := 2) -> AlgMatElt[FldRat]{Returns the gram matrix of an integral lattice constructed from a quaternion algebra over K.}    assert IsTotallyReal(K);    delta := find_delta(K);        delta_signs := [Sign(x) : x in RealEmbeddings(delta)];        ramified_places := [j : j in [1..Degree(K)] | delta_signs[j] eq -1];        // TODO - can also do this with all of them    assert #ramified_places eq Degree(K)-1;        ps_2 := PrimeIdealsOverPrime(K,2);    all_ps := PrimesUpTo(ps_bound,K);    all_ps := [p : p in all_ps | p notin ps_2];        all_ps := [p : p in all_ps | IsPrime(Norm(p))];        ps_2 := [p : p in ps_2 | Norm(p) eq 2];        // Wish I could do this, but it's too slow    //    num_ps := 2*Random(#all_ps div 2);    num_ps := 2*Random(Minimum(3, Maximum((#all_ps-1),0) div 2));    if IsOdd(#ramified_places+split2) then	num_ps +:= 1;    end if;    found := false;    while (not found) do	ps := RandomSubset(Seqset(all_ps), num_ps);	ps := ps_2[1..split2] cat [p : p in ps];	print "Chose ps = ", ps;	print "With norms = ", [Norm(x) : x in ps];		ram := IsEmpty(ps) select 1*Integers(K) else &*ps;		B<i,j> := MyQuaternionAlgebra(ram, [RealPlaces(K)[j] : j in ramified_places]);	alphas := [i,j,i*j];	signs := [{Sign(x) : x in RealEmbeddings(K!(alpha^2)*delta)} : alpha in alphas];	good := [t : t in [1..#signs] | signs[t] eq {1}];	orth := [t : t in [1..#signs] | signs[t] ne {1}];	found := #good ge 2;    end while;    if (sign eq 1) then	alpha := IsEmpty(orth) select alphas[good[1]] else alphas[orth[1]];    else	assert not IsEmpty(orth);	alpha := alphas[good[1]];    end if;    O_B := MaximalOrder(B);        return BuildLattice(O_B, alpha, delta : dual := dual);end intrinsic;// This is not working yet, but that's the goal.function BuildK3Lattice(K)    norms_2 := [Norm(p) : p in PrimeIdealsOverPrime(K,2)];    assert 2 in norms_2;    success := false;    while (not success) do	disc, Q := BuildRandomLattice(K : ps_bound := 1);	Q2 := BuildHalfNeighbor(Q);	success := IsEven(Q2) and IsCyclic(Discriminant(Q2));	print IsEven(Q2), DiscriminantGroup(Q2);    end while;    return Q2;end function;